import {
  type AddFeedRequest,
  type ClusterCard,
  type ClusterDetail,
  type ClusterFeedbackRequest,
  type CreateFilterRuleRequest,
  type Digest,
  type Event,
  type Feed,
  type FilterRule,
  type Folder,
  type ListClustersQuery,
  type Settings,
  type StoryState,
  type UpdateFeedRequest,
  type UpdateFilterRuleRequest,
  type UpdateSettingsRequest,
  settingsSchema
} from "@rss-wrangler/contracts";
import { randomUUID } from "node:crypto";

interface ClusterRecord {
  card: ClusterCard;
  detail: ClusterDetail;
}

const FOLDERS: Folder[] = [
  { id: "11111111-1111-1111-1111-111111111111", name: "Tech" },
  { id: "22222222-2222-2222-2222-222222222222", name: "Gaming" },
  { id: "33333333-3333-3333-3333-333333333333", name: "Security" },
  { id: "44444444-4444-4444-4444-444444444444", name: "Business" },
  { id: "55555555-5555-5555-5555-555555555555", name: "Politics" },
  { id: "66666666-6666-6666-6666-666666666666", name: "Sports" },
  { id: "77777777-7777-7777-7777-777777777777", name: "Design" },
  { id: "88888888-8888-8888-8888-888888888888", name: "Local" },
  { id: "99999999-9999-9999-9999-999999999999", name: "World" },
  { id: "aaaaaaaa-aaaa-aaaa-aaaa-aaaaaaaaaaaa", name: "Other" }
];

const nowIso = () => new Date().toISOString();
const DEFAULT_FOLDER = FOLDERS[0]!;
const OTHER_FOLDER = FOLDERS.find((folder) => folder.name === "Other") ?? DEFAULT_FOLDER;

export class InMemoryStore {
  private readonly folders = [...FOLDERS];
  private readonly feeds: Feed[] = [
    {
      id: "bbbbbbbb-bbbb-bbbb-bbbb-bbbbbbbbbbbb",
      url: "https://example.com/feed.xml",
      title: "Example Tech Feed",
      siteUrl: "https://example.com",
      folderId: DEFAULT_FOLDER.id,
      folderConfidence: 0.91,
      weight: "neutral",
      muted: false,
      trial: false,
      classificationStatus: "approved",
      createdAt: nowIso(),
      lastPolledAt: null
    }
  ];

  private readonly clusters: ClusterRecord[] = [
    {
      card: {
        id: "cccccccc-cccc-cccc-cccc-cccccccccccc",
        headline: "Example story cluster card",
        heroImageUrl: "https://images.unsplash.com/photo-1451187580459-43490279c0fa",
        primarySource: "Example Tech Feed",
        primarySourcePublishedAt: nowIso(),
        outletCount: 2,
        folderId: DEFAULT_FOLDER.id,
        folderName: DEFAULT_FOLDER.name,
        topicId: null,
        topicName: null,
        summary: "Cluster summary placeholder generated by API skeleton.",
        mutedBreakoutReason: null,
        isRead: false,
        isSaved: false
      },
      detail: {
        cluster: {
          id: "cccccccc-cccc-cccc-cccc-cccccccccccc",
          headline: "Example story cluster card",
          heroImageUrl: "https://images.unsplash.com/photo-1451187580459-43490279c0fa",
          primarySource: "Example Tech Feed",
          primarySourcePublishedAt: nowIso(),
          outletCount: 2,
          folderId: DEFAULT_FOLDER.id,
          folderName: DEFAULT_FOLDER.name,
          topicId: null,
          topicName: null,
          summary: "Cluster summary placeholder generated by API skeleton.",
          mutedBreakoutReason: null,
          isRead: false,
          isSaved: false
        },
        storySoFar: "Story so far placeholder.",
        members: [
          {
            itemId: "dddddddd-dddd-dddd-dddd-dddddddddddd",
            title: "Outlet one title",
            sourceName: "Example Tech Feed",
            url: "https://example.com/article-1",
            publishedAt: nowIso()
          },
          {
            itemId: "eeeeeeee-eeee-eeee-eeee-eeeeeeeeeeee",
            title: "Outlet two title",
            sourceName: "Another Outlet",
            url: "https://example.net/article-1",
            publishedAt: nowIso()
          }
        ]
      }
    }
  ];

  private readonly filters: FilterRule[] = [
    {
      id: "ffffffff-ffff-ffff-ffff-ffffffffffff",
      pattern: "roblox",
      type: "phrase",
      mode: "mute",
      breakoutEnabled: true,
      createdAt: nowIso()
    }
  ];

  private readonly digests: Digest[] = [];
  private readonly seenEventKeys = new Set<string>();

  private settings: Settings = settingsSchema.parse({
    aiMode: "summaries_digest",
    aiProvider: "openai",
    monthlyAiCapUsd: 20,
    aiFallbackToLocal: false,
    digestAwayHours: 24,
    digestBacklogThreshold: 50,
    feedPollMinutes: 60
  });

  listClusters(query: ListClustersQuery): { data: ClusterCard[]; nextCursor: string | null } {
    const filtered = this.clusters
      .map((record) => record.card)
      .filter((cluster) => this.matchesState(cluster, query.state))
      .filter((cluster) => !query.folder_id || cluster.folderId === query.folder_id)
      .sort((a, b) => {
        if (query.sort === "latest") {
          return Date.parse(b.primarySourcePublishedAt) - Date.parse(a.primarySourcePublishedAt);
        }

        const aScore = this.personalScore(a);
        const bScore = this.personalScore(b);
        return bScore - aScore;
      });

    const start = query.cursor ? Number.parseInt(query.cursor, 10) || 0 : 0;
    const end = Math.min(start + query.limit, filtered.length);
    const data = filtered.slice(start, end);
    const nextCursor = end < filtered.length ? String(end) : null;

    return { data, nextCursor };
  }

  getCluster(clusterId: string): ClusterDetail | null {
    return this.clusters.find((record) => record.card.id === clusterId)?.detail ?? null;
  }

  markRead(clusterId: string): boolean {
    const record = this.clusters.find((cluster) => cluster.card.id === clusterId);
    if (!record) {
      return false;
    }

    record.card.isRead = true;
    record.detail.cluster.isRead = true;
    return true;
  }

  saveCluster(clusterId: string): boolean {
    const record = this.clusters.find((cluster) => cluster.card.id === clusterId);
    if (!record) {
      return false;
    }

    record.card.isSaved = true;
    record.detail.cluster.isSaved = true;
    return true;
  }

  splitCluster(clusterId: string): boolean {
    return this.clusters.some((cluster) => cluster.card.id === clusterId);
  }

  submitFeedback(clusterId: string, _feedback: ClusterFeedbackRequest): boolean {
    return this.clusters.some((cluster) => cluster.card.id === clusterId);
  }

  listFolders(): Folder[] {
    return this.folders;
  }

  listFeeds(): Feed[] {
    return this.feeds;
  }

  addFeed(payload: AddFeedRequest): Feed {
    const feed: Feed = {
      id: randomUUID(),
      url: payload.url,
      title: payload.url,
      siteUrl: null,
      folderId: this.findFolderByName("Other")?.id ?? OTHER_FOLDER.id,
      folderConfidence: 0.4,
      weight: "neutral",
      muted: false,
      trial: false,
      classificationStatus: "pending_classification",
      createdAt: nowIso(),
      lastPolledAt: null
    };

    this.feeds.push(feed);
    return feed;
  }

  updateFeed(feedId: string, patch: UpdateFeedRequest): Feed | null {
    const feed = this.feeds.find((candidate) => candidate.id === feedId);
    if (!feed) {
      return null;
    }

    if (patch.folderId) {
      feed.folderId = patch.folderId;
    }
    if (patch.weight) {
      feed.weight = patch.weight;
    }
    if (typeof patch.muted === "boolean") {
      feed.muted = patch.muted;
    }
    if (typeof patch.trial === "boolean") {
      feed.trial = patch.trial;
    }

    return feed;
  }

  listFilters(): FilterRule[] {
    return this.filters;
  }

  createFilter(payload: CreateFilterRuleRequest): FilterRule {
    const filter: FilterRule = {
      id: randomUUID(),
      pattern: payload.pattern,
      type: payload.type,
      mode: payload.mode,
      breakoutEnabled: payload.breakoutEnabled,
      createdAt: nowIso()
    };

    this.filters.push(filter);
    return filter;
  }

  updateFilter(filterId: string, patch: UpdateFilterRuleRequest): FilterRule | null {
    const filter = this.filters.find((candidate) => candidate.id === filterId);
    if (!filter) {
      return null;
    }

    if (patch.pattern) {
      filter.pattern = patch.pattern;
    }
    if (patch.type) {
      filter.type = patch.type;
    }
    if (patch.mode) {
      filter.mode = patch.mode;
    }
    if (typeof patch.breakoutEnabled === "boolean") {
      filter.breakoutEnabled = patch.breakoutEnabled;
    }

    return filter;
  }

  deleteFilter(filterId: string): boolean {
    const index = this.filters.findIndex((candidate) => candidate.id === filterId);
    if (index === -1) {
      return false;
    }

    this.filters.splice(index, 1);
    return true;
  }

  listDigests(): Digest[] {
    return this.digests;
  }

  recordEvents(events: Event[]): { accepted: number; deduped: number } {
    let accepted = 0;
    let deduped = 0;

    for (const event of events) {
      if (this.seenEventKeys.has(event.idempotencyKey)) {
        deduped += 1;
        continue;
      }

      this.seenEventKeys.add(event.idempotencyKey);
      accepted += 1;
    }

    return { accepted, deduped };
  }

  getSettings(): Settings {
    return this.settings;
  }

  updateSettings(patch: UpdateSettingsRequest): Settings {
    this.settings = settingsSchema.parse({ ...this.settings, ...patch });
    return this.settings;
  }

  private matchesState(cluster: ClusterCard, state: StoryState): boolean {
    if (state === "all") {
      return true;
    }
    if (state === "saved") {
      return cluster.isSaved;
    }
    return !cluster.isRead;
  }

  private personalScore(cluster: ClusterCard): number {
    const ageHours = Math.max(1, (Date.now() - Date.parse(cluster.primarySourcePublishedAt)) / (1000 * 60 * 60));
    const recency = 1 / ageHours;
    const savedBoost = cluster.isSaved ? 0.5 : 0;
    const outletBoost = Math.min(cluster.outletCount / 10, 1);
    return recency + savedBoost + outletBoost;
  }

  private findFolderByName(name: string): Folder | undefined {
    return this.folders.find((folder) => folder.name.toLowerCase() === name.toLowerCase());
  }
}
